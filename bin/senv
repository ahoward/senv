#! /usr/bin/env ruby
# encoding: utf-8

#
  HELP =<<-____
      VERSION
        <%= Senv.version %>

      TL;DR;

        $ tree ./config/senvs/

          config/senvs/
           development.enc.rb
           development.rb
           development.yml
           development.json
           production.enc.rb
           production.rb
           production.yml
           staging.json
           staging.enc.rb
           staging.rb
           staging.yml
           staging.json


       ~> export SENV=production

       ~> ./bin/senv run-something-in-production senv

       ~> ./bin/senv @staging # show it

       ~> ./bin/senv @staging run-something-in-staging-senv

    ____

#
  require "pathname"
  script_d = Pathname.new(__FILE__).realpath.dirname.to_s

  unless defined?(Senv)
    require File.expand_path("../lib/senv", script_d)
  end

  unless defined?(Senv::Script)
    require File.expand_path("../lib/senv/script", script_d)
  end

#
  Senv.script do
    before do
      $handle_senv_alias_argument = proc do
        if ARGV.first =~ /^@/
          ENV['SENV'] = ARGV.shift.sub(/^@/, '').strip
        end
      end.call

      $handle_cries_for_help = proc do
        if ARGV.delete('-h') || ARGV.delete('--help')
          ARGV.unshift('help')
        end
      end.call
    end

  #
    run do
      #if ARGV.include?('-h') || ARGV.include?('--help')
        #show_help!
      #else
        exec!
      #end
    end

  #
    run 'help' do
      show_help!
    end

  #
    run 'exec' do
      exec!
    end

  #
    run 'init' do
      require "shellwords"

      load_senv!

      Senv.environment.to_hash.each do |key, val|
        if val
          STDOUT.puts "export #{ Shellwords.escape(key) }=#{ Shellwords.escape(val) }"
        else
          STDOUT.puts "unset #{ Shellwords.escape(key) }"
        end
      end
    end

  #
    run '.setup' do
      dir = @argv.shift || Dir.pwd
      key = @argv.shift || @options['key'] || SecureRandom.uuid

      key.strip!

      Dir.chdir(dir) do
        if test(?d, '.senv')
          abort "#{ dir }/.senv directory exists"
        end

        FileUtils.mkdir_p('.senv')

        IO.binwrite('.senv/_key', "#{ key }\n")

        Senv.key = key

        Senv.write(
          '.senv/all.rb',
          u.unindent(
            <<-____
              ENV['A'] = 'one'
              ENV['B'] = 'two'
              ENV['C'] = 'three'
            ____
          )
        )

        %w[ development production ].each do |env|
          Senv.write(
            ".senv/#{ env }.rb",
            u.unindent(
              <<-____
                Senv.load(:all)

                ENV['B'] = 'two (via #{ env }.rb)'
              ____
            )
          )

          Senv.write(
            ".senv/#{ env }.enc.rb",
            u.unindent(
              <<-____
                Senv.load(:all)

                ENV['C'] = 'three (via #{ env }.enc.rb)'
              ____
            )
          )
        end

        puts "[SENV] setup #{ File.expand_path(dir) }" 

        Dir.glob('.senv/**/**').sort.each do |entry|
          next unless test(?f, entry)
          puts "- #{ entry }"
        end
      end
    end

  #
    run '.inspect' do
      load_senv!

      if @argv.empty?
        puts Senv.environment.inspect
      else
        env = {}
        @argv.each do |name|
          env[name] = Senv.environment[name]
        end
        puts env.inspect
      end
    end

  #
    run '.edit' do
      input = @argv[0]
      output = input
      options = @opts

      data =
        if test(?s, input)
          Senv.read(input, options)
        else
          ''
        end

      ext = File.basename(input).split('.').last
      editor = @options['editor'] || ENV['EDITOR'] || 'vim'

      u.tmpfile(:ext => ext) do |tmp|
        tmp.write(data)
        tmp.close

        if(system "#{ editor } #{ tmp.path }")
          data = IO.binread(tmp.path)
          Senv.write(output, data, options)
        end
      end
    end

  #
    run '.read' do
      input = @argv[0] || '-'
      output = @argv[1] || '-'
      options = @options

      data =
        if input == '-'
          Senv.read('/dev/stdin', options)
        else
          Senv.read(input, options)
        end

      if output == '-'
        Senv.write('/dev/stdout', data, options)
      else
        Senv.write(output, data, options)
      end
    end

    run '.write' do
      output = @argv[0] || '-'
      input = @argv[1] || '-'
      options = @options

      data =
        if input == '-'
          Senv.read('/dev/stdin')
        else
          Senv.read(input)
        end

      if output == '-'
        Senv.write('/dev/stdout', data, options)
      else
        Senv.write(output, data, options)
      end
    end

    run '.get' do
      load_senv!

      @argv.each do |name|
        puts ENV[name]
      end
    end

  #
    def show_help!
      help = ERB.new(u.unindent(HELP)).result(::TOPLEVEL_BINDING)
      STDOUT.puts(help)
    end

    def load_senv!
      if @options['debug']
        ENV['SENV_DEBUG'] = 'true'
      end

      if @options['key']
        ENV['SENV_KEY'] = @options['key']
      end

      begin
        Senv.load(:force => @options['force'])
      rescue Senv::Error => e
        abort(e.message)
      end
    end

    def exec!
      load_senv!

      if @argv.empty?
        STDOUT.puts Senv.environment.to_hash.to_yaml
      else
        exec(*@argv)
      end
    end
  end
